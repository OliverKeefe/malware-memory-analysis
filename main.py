#%%
import tensorflow as tf
import tensorflow_addons as tfa
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import zipfile
from os import path
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow import keras
from tensorflow import keras

#%% Callbacks
class desired_accuracy(tf.keras.callbacks.Callback):
    def __init__(self, accuracy):
        self.accuracy = accuracy
    
    def on_epoch_end(self, epoch, logs={}):
        print(f"[*] Accuracy: {logs['accuracy']:.4f}")
        if (logs.get('accuracy') >= self.accuracy):
            print(f"\n[+] {self.accuracy} accuracy achieved. Stopping training...")
            self.model.stop_training = True

#%%
class Initialization:
    def __init__(self, nproc, nppid, avg_threads, nprocs64bit, nactive, ncallbacks, nanonymous, ngeneric, category):
        self.nproc = nproc
        self.nppid = nppid
        self.avg_threads = avg_threads
        self.nprocs64bit = nprocs64bit
        self.nactive = nactive
        self.ncallbacks = ncallbacks
        self.nanonymous = nanonymous
        self.ngeneric = ngeneric
        self.category = category
#%%
def unzip_data(data_path):
    with zipfile.ZipFile(data_path) as data:
        data.extractall("data/")
        print("[+] Dataset extracted successfully.")
#%%
def load_data(dataset_path):
    df = pd.read_csv(dataset_path)
    return df

#%%
def preprocess_data(df):
    le = LabelEncoder()
    df['category'] = le.fit_transform(df['Category'])
    df['class'] = le.fit_transform(df['Class'])
    X = df[['pslist.nproc', 'pslist.nppid', 'pslist.avg_threads',
       'pslist.nprocs64bit', 'pslist.avg_handlers', 'dlllist.ndlls',
       'dlllist.avg_dlls_per_proc', 'handles.nhandles',
       'handles.avg_handles_per_proc', 'handles.nport', 'handles.nfile',
       'handles.nevent', 'handles.ndesktop', 'handles.nkey', 'handles.nthread',
       'handles.ndirectory', 'handles.nsemaphore', 'handles.ntimer',
       'handles.nsection', 'handles.nmutant', 'ldrmodules.not_in_load',
       'ldrmodules.not_in_init', 'ldrmodules.not_in_mem',
       'ldrmodules.not_in_load_avg', 'ldrmodules.not_in_init_avg',
       'ldrmodules.not_in_mem_avg', 'malfind.ninjections',
       'malfind.commitCharge', 'malfind.protection',
       'malfind.uniqueInjections', 'psxview.not_in_pslist',
       'psxview.not_in_eprocess_pool', 'psxview.not_in_ethread_pool',
       'psxview.not_in_pspcid_list', 'psxview.not_in_csrss_handles',
       'psxview.not_in_session', 'psxview.not_in_deskthrd',
       'psxview.not_in_pslist_false_avg',
       'psxview.not_in_eprocess_pool_false_avg',
       'psxview.not_in_ethread_pool_false_avg',
       'psxview.not_in_pspcid_list_false_avg',
       'psxview.not_in_csrss_handles_false_avg',
       'psxview.not_in_session_false_avg', 'psxview.not_in_deskthrd_false_avg',
       'modules.nmodules', 'svcscan.nservices', 'svcscan.kernel_drivers',
       'svcscan.fs_drivers', 'svcscan.process_services',
       'svcscan.shared_process_services',
       'svcscan.interactive_process_services', 'svcscan.nactive',
       'callbacks.ncallbacks', 'callbacks.nanonymous', 'callbacks.ngeneric']]
    #X = df.drop('Category', axis=1)
    X = X.apply(pd.to_numeric, errors='coerce') # Convert all columns to numeric, coercing errors
    X = X.astype('float32')
    y = df['class']
    X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
    y_train = le.fit_transform(y_train)
    y_valid = le.transform(y_valid)
    print(X.shape, y.shape)
    return X_train, X_valid, y_train, y_valid
    

#%%
def create_model():
    model = keras.Sequential([
        keras.layers.Dense(64, activation='relu', input_shape=(None, 55)),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(64, activation='relu'),
        keras.layers.Dense(1, activation='sigmoid')
    ])
    
    return model

#%%
def main():
    zip_file_path = "data/Obfuscated-MalMem2022.csv.zip"
    if path.exists("data/obfuscated-malmem2022.csv"):
        print("[+] Dataset is present.")
    else:
        try:
            unzip_data(zip_file_path)
        except:
            print("[!] Error, unable to locate dataset zip file. Aborting...")

    df = load_data("data/Obfuscated-MalMem2022.csv")
    print(df)
    X_train, X_valid, y_train, y_valid = preprocess_data(df)
    model = create_model()
    model.summary()
    model.compile(loss='binary_crossentropy', 
                  optimizer='adam', 
                  metrics=['accuracy'])
    desired_acc_callback = desired_accuracy(0.9999)
    model.fit(
        X_train, 
        y_train,
        epochs=15,
        callbacks=[desired_acc_callback],
        validation_data=(X_valid, y_valid))
    model.save("obfuscated_malware_memory_classifier.h5")
    
if __name__ == "__main__":
    main()

# %%
